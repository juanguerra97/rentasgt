/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.4.0 (NJsonSchema v10.1.26.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IChatRoomsClient {
    get(pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfChatRoomDto>;
    create(command: CreateChatRoomCommand): Observable<number>;
    getRoomForProduct(productId: number): Observable<ChatRoomDto>;
    getMessages(id: number, pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfChatMessageDto>;
    getById(id: number): Observable<ChatRoomDto>;
    readMessage(command: ReadMessageCommand): Observable<ChatMessageDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ChatRoomsClient implements IChatRoomsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfChatRoomDto> {
        let url_ = this.baseUrl + "/api/ChatRooms?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListResponseOfChatRoomDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListResponseOfChatRoomDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListResponseOfChatRoomDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListResponseOfChatRoomDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListResponseOfChatRoomDto>(<any>null);
    }

    create(command: CreateChatRoomCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ChatRooms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    getRoomForProduct(productId: number): Observable<ChatRoomDto> {
        let url_ = this.baseUrl + "/api/ChatRooms/product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoomForProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoomForProduct(<any>response_);
                } catch (e) {
                    return <Observable<ChatRoomDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatRoomDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoomForProduct(response: HttpResponseBase): Observable<ChatRoomDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatRoomDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatRoomDto>(<any>null);
    }

    getMessages(id: number, pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/ChatRooms/{id}/messages?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessages(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListResponseOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListResponseOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMessages(response: HttpResponseBase): Observable<PaginatedListResponseOfChatMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListResponseOfChatMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListResponseOfChatMessageDto>(<any>null);
    }

    getById(id: number): Observable<ChatRoomDto> {
        let url_ = this.baseUrl + "/api/ChatRooms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ChatRoomDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatRoomDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ChatRoomDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatRoomDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatRoomDto>(<any>null);
    }

    readMessage(command: ReadMessageCommand): Observable<ChatMessageDto> {
        let url_ = this.baseUrl + "/api/ChatRooms/messages/read";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReadMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadMessage(<any>response_);
                } catch (e) {
                    return <Observable<ChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processReadMessage(response: HttpResponseBase): Observable<ChatMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatMessageDto>(<any>null);
    }
}

export interface ICategoriesClient {
    get(pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfCategoryDto>;
    create(command: CreateCategoryCommand): Observable<number>;
    getById(id: number): Observable<CategoryDto>;
    update(id: number, command: UpdateCategoryCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getProducts(id: number, pageSize: number | undefined, pageNumber: number | undefined): Observable<ProductDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class CategoriesClient implements ICategoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Categories?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListResponseOfCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListResponseOfCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListResponseOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListResponseOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListResponseOfCategoryDto>(<any>null);
    }

    create(command: CreateCategoryCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    getById(id: number): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDto>(<any>null);
    }

    update(id: number, command: UpdateCategoryCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getProducts(id: number, pageSize: number | undefined, pageNumber: number | undefined): Observable<ProductDto[]> {
        let url_ = this.baseUrl + "/api/Categories/{id}/products?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<ProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto[]>(<any>null);
    }
}

export interface IConflictRecordsClient {
    getConflictRecords(id: number): Observable<ConflictRecordDto[]>;
    create(command: CreateConflictRecordCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class ConflictRecordsClient implements IConflictRecordsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getConflictRecords(id: number): Observable<ConflictRecordDto[]> {
        let url_ = this.baseUrl + "/api/ConflictRecords/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConflictRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConflictRecords(<any>response_);
                } catch (e) {
                    return <Observable<ConflictRecordDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConflictRecordDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetConflictRecords(response: HttpResponseBase): Observable<ConflictRecordDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConflictRecordDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConflictRecordDto[]>(<any>null);
    }

    create(command: CreateConflictRecordCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/ConflictRecords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

export interface IConflictsClient {
    getConflicts(pageSize: number | undefined, pageNumber: number | undefined, conflictStatus: number | null | undefined, moderatorId: string | null | undefined): Observable<PaginatedListResponseOfConflictDto>;
    create(command: CreateConflictCommand): Observable<number>;
    cancel(id: number): Observable<FileResponse>;
    finish(id: number): Observable<FileResponse>;
    moderate(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ConflictsClient implements IConflictsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getConflicts(pageSize: number | undefined, pageNumber: number | undefined, conflictStatus: number | null | undefined, moderatorId: string | null | undefined): Observable<PaginatedListResponseOfConflictDto> {
        let url_ = this.baseUrl + "/api/Conflicts?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (conflictStatus !== undefined && conflictStatus !== null)
            url_ += "conflictStatus=" + encodeURIComponent("" + conflictStatus) + "&";
        if (moderatorId !== undefined && moderatorId !== null)
            url_ += "moderatorId=" + encodeURIComponent("" + moderatorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConflicts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConflicts(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListResponseOfConflictDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListResponseOfConflictDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConflicts(response: HttpResponseBase): Observable<PaginatedListResponseOfConflictDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListResponseOfConflictDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListResponseOfConflictDto>(<any>null);
    }

    create(command: CreateConflictCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Conflicts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    cancel(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Conflicts/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    finish(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Conflicts/{id}/finish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinish(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processFinish(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    moderate(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Conflicts/{id}/moderate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processModerate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processModerate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processModerate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IPicturesClient {
    uploadPublicPicture(imageFile: FileParameter | null | undefined): Observable<number>;
    uploadPrivatePicture(imageFile: FileParameter | null | undefined): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class PicturesClient implements IPicturesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    uploadPublicPicture(imageFile: FileParameter | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Pictures/upload/public";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imageFile !== null && imageFile !== undefined)
            content_.append("ImageFile", imageFile.data, imageFile.fileName ? imageFile.fileName : "ImageFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadPublicPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadPublicPicture(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUploadPublicPicture(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    uploadPrivatePicture(imageFile: FileParameter | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Pictures/upload/private";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (imageFile !== null && imageFile !== undefined)
            content_.append("ImageFile", imageFile.data, imageFile.fileName ? imageFile.fileName : "ImageFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadPrivatePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadPrivatePicture(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUploadPrivatePicture(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

export interface IProductCategoriesClient {
    create(command: CreateProductCategoryCommand): Observable<FileResponse>;
    delete(productId: number, categoryId: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductCategoriesClient implements IProductCategoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(command: CreateProductCategoryCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(productId: number, categoryId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductCategories/{productId}/{categoryId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IProductsClient {
    get(pageSize: number | undefined, pageNumber: number | undefined, name: string | null | undefined, category: number | null | undefined, lon: number | null | undefined, lat: number | null | undefined, d: number | undefined, city: string | null | undefined, state: string | null | undefined): Observable<PaginatedListResponseOfProductDto>;
    create(command: CreateProductCommand): Observable<number>;
    getProductsOfOwner(pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfProductDto>;
    getById(id: number): Observable<ProductDto>;
    update(id: number, command: UpdateProductCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getCategories(id: number): Observable<CategorySummaryDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductsClient implements IProductsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(pageSize: number | undefined, pageNumber: number | undefined, name: string | null | undefined, category: number | null | undefined, lon: number | null | undefined, lat: number | null | undefined, d: number | undefined, city: string | null | undefined, state: string | null | undefined): Observable<PaginatedListResponseOfProductDto> {
        let url_ = this.baseUrl + "/api/Products?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (category !== undefined && category !== null)
            url_ += "category=" + encodeURIComponent("" + category) + "&";
        if (lon !== undefined && lon !== null)
            url_ += "lon=" + encodeURIComponent("" + lon) + "&";
        if (lat !== undefined && lat !== null)
            url_ += "lat=" + encodeURIComponent("" + lat) + "&";
        if (d === null)
            throw new Error("The parameter 'd' cannot be null.");
        else if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&";
        if (city !== undefined && city !== null)
            url_ += "city=" + encodeURIComponent("" + city) + "&";
        if (state !== undefined && state !== null)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListResponseOfProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListResponseOfProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListResponseOfProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListResponseOfProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListResponseOfProductDto>(<any>null);
    }

    create(command: CreateProductCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    getProductsOfOwner(pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfProductDto> {
        let url_ = this.baseUrl + "/api/Products/owner?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsOfOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsOfOwner(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListResponseOfProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListResponseOfProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductsOfOwner(response: HttpResponseBase): Observable<PaginatedListResponseOfProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListResponseOfProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListResponseOfProductDto>(<any>null);
    }

    getById(id: number): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto>(<any>null);
    }

    update(id: number, command: UpdateProductCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getCategories(id: number): Observable<CategorySummaryDto[]> {
        let url_ = this.baseUrl + "/api/Products/{id}/categories";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategories(<any>response_);
                } catch (e) {
                    return <Observable<CategorySummaryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategorySummaryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategories(response: HttpResponseBase): Observable<CategorySummaryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategorySummaryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategorySummaryDto[]>(<any>null);
    }
}

export interface IRatingToProductsClient {
    getPending(): Observable<RatingToProductDto>;
    getRatingsForProduct(id: number, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListResponseOfRatingToProductDto>;
    rate(id: number, command: RateProductCommand): Observable<number>;
    ignore(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class RatingToProductsClient implements IRatingToProductsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getPending(): Observable<RatingToProductDto> {
        let url_ = this.baseUrl + "/api/RatingToProducts/pending";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPending(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPending(<any>response_);
                } catch (e) {
                    return <Observable<RatingToProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RatingToProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPending(response: HttpResponseBase): Observable<RatingToProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RatingToProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RatingToProductDto>(<any>null);
    }

    getRatingsForProduct(id: number, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListResponseOfRatingToProductDto> {
        let url_ = this.baseUrl + "/api/RatingToProducts/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRatingsForProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRatingsForProduct(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListResponseOfRatingToProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListResponseOfRatingToProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRatingsForProduct(response: HttpResponseBase): Observable<PaginatedListResponseOfRatingToProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListResponseOfRatingToProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListResponseOfRatingToProductDto>(<any>null);
    }

    rate(id: number, command: RateProductCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/RatingToProducts/{id}/rate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processRate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    ignore(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RatingToProducts/{id}/ignore";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIgnore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIgnore(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processIgnore(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IRatingToUsersClient {
    getPendingRating(): Observable<RatingToUserDto>;
    rateUser(command: RateUserCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class RatingToUsersClient implements IRatingToUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getPendingRating(): Observable<RatingToUserDto> {
        let url_ = this.baseUrl + "/api/RatingToUsers/pending";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingRating(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingRating(<any>response_);
                } catch (e) {
                    return <Observable<RatingToUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RatingToUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPendingRating(response: HttpResponseBase): Observable<RatingToUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RatingToUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RatingToUserDto>(<any>null);
    }

    rateUser(command: RateUserCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/RatingToUsers/rate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRateUser(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processRateUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

export interface IRentRequestsClient {
    view(id: number): Observable<FileResponse>;
    cancel(id: number): Observable<FileResponse>;
    reject(id: number, command: RejectRentRequestCommand): Observable<FileResponse>;
    accept(id: number): Observable<FileResponse>;
    getPending(pageSize: number | undefined, pageNumber: number | undefined): Observable<RentRequestDto[]>;
    getOfRequestor(pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfRentRequestDto>;
    getOfOwner(pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfRentRequestDto>;
    getHistory(id: number): Observable<RequestEventDto[]>;
    create(command: CreateRentRequestCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class RentRequestsClient implements IRentRequestsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    view(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RentRequests/{id}/view";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processView(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processView(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    cancel(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RentRequests/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    reject(id: number, command: RejectRentRequestCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RentRequests/{id}/reject";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReject(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processReject(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    accept(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RentRequests/{id}/accept";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccept(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccept(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAccept(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getPending(pageSize: number | undefined, pageNumber: number | undefined): Observable<RentRequestDto[]> {
        let url_ = this.baseUrl + "/api/RentRequests/pending?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPending(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPending(<any>response_);
                } catch (e) {
                    return <Observable<RentRequestDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RentRequestDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPending(response: HttpResponseBase): Observable<RentRequestDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RentRequestDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RentRequestDto[]>(<any>null);
    }

    getOfRequestor(pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfRentRequestDto> {
        let url_ = this.baseUrl + "/api/RentRequests/requestor?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOfRequestor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOfRequestor(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListResponseOfRentRequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListResponseOfRentRequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOfRequestor(response: HttpResponseBase): Observable<PaginatedListResponseOfRentRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListResponseOfRentRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListResponseOfRentRequestDto>(<any>null);
    }

    getOfOwner(pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfRentRequestDto> {
        let url_ = this.baseUrl + "/api/RentRequests/owner?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOfOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOfOwner(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListResponseOfRentRequestDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListResponseOfRentRequestDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOfOwner(response: HttpResponseBase): Observable<PaginatedListResponseOfRentRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListResponseOfRentRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListResponseOfRentRequestDto>(<any>null);
    }

    getHistory(id: number): Observable<RequestEventDto[]> {
        let url_ = this.baseUrl + "/api/RentRequests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistory(<any>response_);
                } catch (e) {
                    return <Observable<RequestEventDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestEventDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHistory(response: HttpResponseBase): Observable<RequestEventDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestEventDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestEventDto[]>(<any>null);
    }

    create(command: CreateRentRequestCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/RentRequests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

export interface IRentsClient {
    getById(id: number): Observable<RentDto>;
    getOfRequestor(pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfRentRequestRentDto>;
    getOfOwner(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListResponseOfRentRequestRentDto>;
    startRent(id: number): Observable<FileResponse>;
    endRent(id: number, command: EndRentCommand): Observable<FileResponse>;
    cancelRent(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class RentsClient implements IRentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getById(id: number): Observable<RentDto> {
        let url_ = this.baseUrl + "/api/Rents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<RentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<RentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RentDto>(<any>null);
    }

    getOfRequestor(pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListResponseOfRentRequestRentDto> {
        let url_ = this.baseUrl + "/api/Rents?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOfRequestor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOfRequestor(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListResponseOfRentRequestRentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListResponseOfRentRequestRentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOfRequestor(response: HttpResponseBase): Observable<PaginatedListResponseOfRentRequestRentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListResponseOfRentRequestRentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListResponseOfRentRequestRentDto>(<any>null);
    }

    getOfOwner(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListResponseOfRentRequestRentDto> {
        let url_ = this.baseUrl + "/api/Rents/owner?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOfOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOfOwner(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListResponseOfRentRequestRentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListResponseOfRentRequestRentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOfOwner(response: HttpResponseBase): Observable<PaginatedListResponseOfRentRequestRentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListResponseOfRentRequestRentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListResponseOfRentRequestRentDto>(<any>null);
    }

    startRent(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Rents/{id}/start";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartRent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartRent(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStartRent(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    endRent(id: number, command: EndRentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Rents/{id}/end";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEndRent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEndRent(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processEndRent(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    cancelRent(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Rents/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelRent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelRent(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCancelRent(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IReportsClient {
    getRentsByDay(year: number | undefined, month: number | undefined): Observable<RentsByDayReport>;
    getRentsByMonth(year: number | undefined): Observable<RentsByMonthReport>;
    getRentsByYear(): Observable<RentsByYearReport>;
}

@Injectable({
    providedIn: 'root'
})
export class ReportsClient implements IReportsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getRentsByDay(year: number | undefined, month: number | undefined): Observable<RentsByDayReport> {
        let url_ = this.baseUrl + "/api/Reports/byday?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRentsByDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRentsByDay(<any>response_);
                } catch (e) {
                    return <Observable<RentsByDayReport>><any>_observableThrow(e);
                }
            } else
                return <Observable<RentsByDayReport>><any>_observableThrow(response_);
        }));
    }

    protected processGetRentsByDay(response: HttpResponseBase): Observable<RentsByDayReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RentsByDayReport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RentsByDayReport>(<any>null);
    }

    getRentsByMonth(year: number | undefined): Observable<RentsByMonthReport> {
        let url_ = this.baseUrl + "/api/Reports/bymonth?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRentsByMonth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRentsByMonth(<any>response_);
                } catch (e) {
                    return <Observable<RentsByMonthReport>><any>_observableThrow(e);
                }
            } else
                return <Observable<RentsByMonthReport>><any>_observableThrow(response_);
        }));
    }

    protected processGetRentsByMonth(response: HttpResponseBase): Observable<RentsByMonthReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RentsByMonthReport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RentsByMonthReport>(<any>null);
    }

    getRentsByYear(): Observable<RentsByYearReport> {
        let url_ = this.baseUrl + "/api/Reports/byyear";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRentsByYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRentsByYear(<any>response_);
                } catch (e) {
                    return <Observable<RentsByYearReport>><any>_observableThrow(e);
                }
            } else
                return <Observable<RentsByYearReport>><any>_observableThrow(response_);
        }));
    }

    protected processGetRentsByYear(response: HttpResponseBase): Observable<RentsByYearReport> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RentsByYearReport.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RentsByYearReport>(<any>null);
    }
}

export interface ITodoItemsClient {
    create(command: CreateTodoItemCommand): Observable<number>;
    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoItemsClient implements ITodoItemsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(command: CreateTodoItemCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/UpdateItemDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItemDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItemDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateItemDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ITodoListsClient {
    get(): Observable<TodosVm>;
    create(command: CreateTodoListCommand): Observable<number>;
    get2(id: number): Observable<FileResponse>;
    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoListsClient implements ITodoListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<TodosVm> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TodosVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<TodosVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TodosVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodosVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TodosVm>(<any>null);
    }

    create(command: CreateTodoListCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get2(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IUsersClient {
    getPendingApprovalProfiles(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListResponseOfUserProfileDto>;
    getUserProfile(): Observable<UserProfileDto>;
    updateDpi(id: string | null, userId: string | null | undefined, cui: string | null | undefined, dpiPictureFile: FileParameter | null | undefined, userPictureFile: FileParameter | null | undefined): Observable<FileResponse>;
    updateAddress(id: string | null, userId: string | null | undefined, address: string | null | undefined, addressPictureFile: FileParameter | null | undefined): Observable<FileResponse>;
    updateProfileInfo(id: string | null, userId: string | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, profilePictureFile: FileParameter | null | undefined): Observable<FileResponse>;
    approveDpi(id: string | null): Observable<FileResponse>;
    approveAddress(id: string | null): Observable<FileResponse>;
    rejectProfile(id: string | null): Observable<FileResponse>;
    sendPhoneVerificationCode(command: SendPhoneNumberVerificationCode): Observable<FileResponse>;
    validatePhoneVerificationCode(command: ValidateUserPhoneNumberCommand): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getPendingApprovalProfiles(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListResponseOfUserProfileDto> {
        let url_ = this.baseUrl + "/api/Users/pending?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingApprovalProfiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingApprovalProfiles(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListResponseOfUserProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListResponseOfUserProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPendingApprovalProfiles(response: HttpResponseBase): Observable<PaginatedListResponseOfUserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListResponseOfUserProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListResponseOfUserProfileDto>(<any>null);
    }

    getUserProfile(): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/Users/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<UserProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfileDto>(<any>null);
    }

    updateDpi(id: string | null, userId: string | null | undefined, cui: string | null | undefined, dpiPictureFile: FileParameter | null | undefined, userPictureFile: FileParameter | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}/profile/dpi";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (userId !== null && userId !== undefined)
            content_.append("UserId", userId.toString());
        if (cui !== null && cui !== undefined)
            content_.append("Cui", cui.toString());
        if (dpiPictureFile !== null && dpiPictureFile !== undefined)
            content_.append("DpiPictureFile", dpiPictureFile.data, dpiPictureFile.fileName ? dpiPictureFile.fileName : "DpiPictureFile");
        if (userPictureFile !== null && userPictureFile !== undefined)
            content_.append("UserPictureFile", userPictureFile.data, userPictureFile.fileName ? userPictureFile.fileName : "UserPictureFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDpi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDpi(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDpi(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateAddress(id: string | null, userId: string | null | undefined, address: string | null | undefined, addressPictureFile: FileParameter | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}/profile/address";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (userId !== null && userId !== undefined)
            content_.append("UserId", userId.toString());
        if (address !== null && address !== undefined)
            content_.append("Address", address.toString());
        if (addressPictureFile !== null && addressPictureFile !== undefined)
            content_.append("AddressPictureFile", addressPictureFile.data, addressPictureFile.fileName ? addressPictureFile.fileName : "AddressPictureFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAddress(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAddress(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateProfileInfo(id: string | null, userId: string | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, profilePictureFile: FileParameter | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}/profile/info";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (userId !== null && userId !== undefined)
            content_.append("UserId", userId.toString());
        if (firstName !== null && firstName !== undefined)
            content_.append("FirstName", firstName.toString());
        if (lastName !== null && lastName !== undefined)
            content_.append("LastName", lastName.toString());
        if (profilePictureFile !== null && profilePictureFile !== undefined)
            content_.append("ProfilePictureFile", profilePictureFile.data, profilePictureFile.fileName ? profilePictureFile.fileName : "ProfilePictureFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfileInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfileInfo(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfileInfo(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    approveDpi(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}/approveDpi";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveDpi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveDpi(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processApproveDpi(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    approveAddress(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}/approveAddress";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveAddress(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processApproveAddress(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    rejectProfile(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}/rejectProfile";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectProfile(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRejectProfile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    sendPhoneVerificationCode(command: SendPhoneNumberVerificationCode): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/sendPhoneCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPhoneVerificationCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPhoneVerificationCode(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSendPhoneVerificationCode(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    validatePhoneVerificationCode(command: ValidateUserPhoneNumberCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Users/validatePhone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidatePhoneVerificationCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidatePhoneVerificationCode(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processValidatePhoneVerificationCode(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export interface IWeatherForecastClient {
    get(): Observable<WeatherForecast[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClient implements IWeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WeatherForecast[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeatherForecast[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeatherForecast[]>(<any>null);
    }
}

export class PaginatedListResponseOfChatRoomDto implements IPaginatedListResponseOfChatRoomDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: ChatRoomDto[] | undefined;

    constructor(data?: IPaginatedListResponseOfChatRoomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatRoomDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListResponseOfChatRoomDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListResponseOfChatRoomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaginatedListResponseOfChatRoomDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: ChatRoomDto[] | undefined;
}

export class ChatRoomDto implements IChatRoomDto {
    id?: number;
    product?: ChatRoomProductDto | undefined;
    user?: ChatUserDto | undefined;
    lastMessage?: ChatMessageDto | undefined;

    constructor(data?: IChatRoomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.product = _data["product"] ? ChatRoomProductDto.fromJS(_data["product"]) : <any>undefined;
            this.user = _data["user"] ? ChatUserDto.fromJS(_data["user"]) : <any>undefined;
            this.lastMessage = _data["lastMessage"] ? ChatMessageDto.fromJS(_data["lastMessage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChatRoomDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["lastMessage"] = this.lastMessage ? this.lastMessage.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IChatRoomDto {
    id?: number;
    product?: ChatRoomProductDto | undefined;
    user?: ChatUserDto | undefined;
    lastMessage?: ChatMessageDto | undefined;
}

export class ChatRoomProductDto implements IChatRoomProductDto {
    id?: number;
    name?: string | undefined;
    owner?: ChatUserDto | undefined;

    constructor(data?: IChatRoomProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.owner = _data["owner"] ? ChatUserDto.fromJS(_data["owner"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChatRoomProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRoomProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IChatRoomProductDto {
    id?: number;
    name?: string | undefined;
    owner?: ChatUserDto | undefined;
}

export class ChatUserDto implements IChatUserDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;

    constructor(data?: IChatUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): ChatUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data; 
    }
}

export interface IChatUserDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
}

export class ChatMessageDto implements IChatMessageDto {
    id?: number;
    roomId?: number;
    status?: ChatMessageStatus;
    sender?: ChatUserDto | undefined;
    sentDate?: Date | undefined;
    content?: string | undefined;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roomId = _data["roomId"];
            this.status = _data["status"];
            this.sender = _data["sender"] ? ChatUserDto.fromJS(_data["sender"]) : <any>undefined;
            this.sentDate = _data["sentDate"] ? new Date(_data["sentDate"].toString()) : <any>undefined;
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roomId"] = this.roomId;
        data["status"] = this.status;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["sentDate"] = this.sentDate ? this.sentDate.toISOString() : <any>undefined;
        data["content"] = this.content;
        return data; 
    }
}

export interface IChatMessageDto {
    id?: number;
    roomId?: number;
    status?: ChatMessageStatus;
    sender?: ChatUserDto | undefined;
    sentDate?: Date | undefined;
    content?: string | undefined;
}

export enum ChatMessageStatus {
    SinEnviar = 0,
    SinLeer = 1,
    Leido = 2,
}

export class PaginatedListResponseOfChatMessageDto implements IPaginatedListResponseOfChatMessageDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: ChatMessageDto[] | undefined;

    constructor(data?: IPaginatedListResponseOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListResponseOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListResponseOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaginatedListResponseOfChatMessageDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: ChatMessageDto[] | undefined;
}

export class CreateChatRoomCommand implements ICreateChatRoomCommand {
    productId?: number;
    firstMessage?: string | undefined;

    constructor(data?: ICreateChatRoomCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.firstMessage = _data["firstMessage"];
        }
    }

    static fromJS(data: any): CreateChatRoomCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChatRoomCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["firstMessage"] = this.firstMessage;
        return data; 
    }
}

export interface ICreateChatRoomCommand {
    productId?: number;
    firstMessage?: string | undefined;
}

export class ReadMessageCommand implements IReadMessageCommand {
    messageId?: number;

    constructor(data?: IReadMessageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.messageId = _data["messageId"];
        }
    }

    static fromJS(data: any): ReadMessageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReadMessageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageId"] = this.messageId;
        return data; 
    }
}

export interface IReadMessageCommand {
    messageId?: number;
}

export class PaginatedListResponseOfCategoryDto implements IPaginatedListResponseOfCategoryDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: CategoryDto[] | undefined;

    constructor(data?: IPaginatedListResponseOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListResponseOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListResponseOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaginatedListResponseOfCategoryDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: CategoryDto[] | undefined;
}

export class CategoryDto implements ICategoryDto {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICategoryDto {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class ProductDto implements IProductDto {
    id?: number;
    status?: number;
    name?: string | undefined;
    description?: string | undefined;
    otherNames?: string | undefined;
    owner?: ProductOwnerDto | undefined;
    location?: UbicacionDto | undefined;
    costPerDay?: number;
    costPerWeek?: number | undefined;
    costPerMonth?: number | undefined;
    rating?: number | undefined;
    distanceInKm?: number | undefined;
    pictures?: ProductPictureDto[] | undefined;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.otherNames = _data["otherNames"];
            this.owner = _data["owner"] ? ProductOwnerDto.fromJS(_data["owner"]) : <any>undefined;
            this.location = _data["location"] ? UbicacionDto.fromJS(_data["location"]) : <any>undefined;
            this.costPerDay = _data["costPerDay"];
            this.costPerWeek = _data["costPerWeek"];
            this.costPerMonth = _data["costPerMonth"];
            this.rating = _data["rating"];
            this.distanceInKm = _data["distanceInKm"];
            if (Array.isArray(_data["pictures"])) {
                this.pictures = [] as any;
                for (let item of _data["pictures"])
                    this.pictures!.push(ProductPictureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        data["description"] = this.description;
        data["otherNames"] = this.otherNames;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["costPerDay"] = this.costPerDay;
        data["costPerWeek"] = this.costPerWeek;
        data["costPerMonth"] = this.costPerMonth;
        data["rating"] = this.rating;
        data["distanceInKm"] = this.distanceInKm;
        if (Array.isArray(this.pictures)) {
            data["pictures"] = [];
            for (let item of this.pictures)
                data["pictures"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductDto {
    id?: number;
    status?: number;
    name?: string | undefined;
    description?: string | undefined;
    otherNames?: string | undefined;
    owner?: ProductOwnerDto | undefined;
    location?: UbicacionDto | undefined;
    costPerDay?: number;
    costPerWeek?: number | undefined;
    costPerMonth?: number | undefined;
    rating?: number | undefined;
    distanceInKm?: number | undefined;
    pictures?: ProductPictureDto[] | undefined;
}

export class ProductOwnerDto implements IProductOwnerDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    reputation?: number | undefined;

    constructor(data?: IProductOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.reputation = _data["reputation"];
        }
    }

    static fromJS(data: any): ProductOwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["reputation"] = this.reputation;
        return data; 
    }
}

export interface IProductOwnerDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    reputation?: number | undefined;
}

export class UbicacionDto implements IUbicacionDto {
    latitude?: number;
    longitude?: number;
    city?: string | undefined;
    state?: string | undefined;
    staticMap?: string | undefined;

    constructor(data?: IUbicacionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.staticMap = _data["staticMap"];
        }
    }

    static fromJS(data: any): UbicacionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UbicacionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["city"] = this.city;
        data["state"] = this.state;
        data["staticMap"] = this.staticMap;
        return data; 
    }
}

export interface IUbicacionDto {
    latitude?: number;
    longitude?: number;
    city?: string | undefined;
    state?: string | undefined;
    staticMap?: string | undefined;
}

export class ProductPictureDto implements IProductPictureDto {
    pictureId?: number;
    storageType?: number;
    pictureContent?: string | undefined;

    constructor(data?: IProductPictureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pictureId = _data["pictureId"];
            this.storageType = _data["storageType"];
            this.pictureContent = _data["pictureContent"];
        }
    }

    static fromJS(data: any): ProductPictureDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPictureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pictureId"] = this.pictureId;
        data["storageType"] = this.storageType;
        data["pictureContent"] = this.pictureContent;
        return data; 
    }
}

export interface IProductPictureDto {
    pictureId?: number;
    storageType?: number;
    pictureContent?: string | undefined;
}

export class CreateCategoryCommand implements ICreateCategoryCommand {
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateCategoryCommand {
    name?: string | undefined;
    description?: string | undefined;
}

export class UpdateCategoryCommand implements IUpdateCategoryCommand {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateCategoryCommand {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class ConflictRecordDto implements IConflictRecordDto {
    id?: number;
    conflictId?: number;
    description?: string | undefined;
    recordDate?: Date;

    constructor(data?: IConflictRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.conflictId = _data["conflictId"];
            this.description = _data["description"];
            this.recordDate = _data["recordDate"] ? new Date(_data["recordDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ConflictRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConflictRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["conflictId"] = this.conflictId;
        data["description"] = this.description;
        data["recordDate"] = this.recordDate ? this.recordDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IConflictRecordDto {
    id?: number;
    conflictId?: number;
    description?: string | undefined;
    recordDate?: Date;
}

export class CreateConflictRecordCommand implements ICreateConflictRecordCommand {
    conflictId?: number;
    description?: string | undefined;

    constructor(data?: ICreateConflictRecordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conflictId = _data["conflictId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateConflictRecordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateConflictRecordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conflictId"] = this.conflictId;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateConflictRecordCommand {
    conflictId?: number;
    description?: string | undefined;
}

export class PaginatedListResponseOfConflictDto implements IPaginatedListResponseOfConflictDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: ConflictDto[] | undefined;

    constructor(data?: IPaginatedListResponseOfConflictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ConflictDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListResponseOfConflictDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListResponseOfConflictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaginatedListResponseOfConflictDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: ConflictDto[] | undefined;
}

export class ConflictDto implements IConflictDto {
    id?: number;
    status?: ConflictStatus;
    rentId?: number;
    rent?: RentConflictDto | undefined;
    moderatorId?: string | undefined;
    moderator?: UserConflictDto | undefined;
    description?: string | undefined;
    complainantId?: string | undefined;
    complainant?: UserConflictDto | undefined;
    conflictDate?: Date;
    conflictRecords?: ConflictRecordDto[] | undefined;

    constructor(data?: IConflictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.rentId = _data["rentId"];
            this.rent = _data["rent"] ? RentConflictDto.fromJS(_data["rent"]) : <any>undefined;
            this.moderatorId = _data["moderatorId"];
            this.moderator = _data["moderator"] ? UserConflictDto.fromJS(_data["moderator"]) : <any>undefined;
            this.description = _data["description"];
            this.complainantId = _data["complainantId"];
            this.complainant = _data["complainant"] ? UserConflictDto.fromJS(_data["complainant"]) : <any>undefined;
            this.conflictDate = _data["conflictDate"] ? new Date(_data["conflictDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["conflictRecords"])) {
                this.conflictRecords = [] as any;
                for (let item of _data["conflictRecords"])
                    this.conflictRecords!.push(ConflictRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConflictDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConflictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["rentId"] = this.rentId;
        data["rent"] = this.rent ? this.rent.toJSON() : <any>undefined;
        data["moderatorId"] = this.moderatorId;
        data["moderator"] = this.moderator ? this.moderator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["complainantId"] = this.complainantId;
        data["complainant"] = this.complainant ? this.complainant.toJSON() : <any>undefined;
        data["conflictDate"] = this.conflictDate ? this.conflictDate.toISOString() : <any>undefined;
        if (Array.isArray(this.conflictRecords)) {
            data["conflictRecords"] = [];
            for (let item of this.conflictRecords)
                data["conflictRecords"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IConflictDto {
    id?: number;
    status?: ConflictStatus;
    rentId?: number;
    rent?: RentConflictDto | undefined;
    moderatorId?: string | undefined;
    moderator?: UserConflictDto | undefined;
    description?: string | undefined;
    complainantId?: string | undefined;
    complainant?: UserConflictDto | undefined;
    conflictDate?: Date;
    conflictRecords?: ConflictRecordDto[] | undefined;
}

export enum ConflictStatus {
    Pending = 0,
    Cancelled = 1,
    InProcess = 2,
    Finished = 3,
}

export class RentConflictDto implements IRentConflictDto {
    requestId?: number;
    request?: RentRequestConflictDto | undefined;
    status?: RentStatus;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    totalCost?: number | undefined;

    constructor(data?: IRentConflictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.request = _data["request"] ? RentRequestConflictDto.fromJS(_data["request"]) : <any>undefined;
            this.status = _data["status"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.totalCost = _data["totalCost"];
        }
    }

    static fromJS(data: any): RentConflictDto {
        data = typeof data === 'object' ? data : {};
        let result = new RentConflictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["totalCost"] = this.totalCost;
        return data; 
    }
}

export interface IRentConflictDto {
    requestId?: number;
    request?: RentRequestConflictDto | undefined;
    status?: RentStatus;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    totalCost?: number | undefined;
}

export class RentRequestConflictDto implements IRentRequestConflictDto {
    id?: number;
    status?: RequestStatus;
    requestDate?: Date;
    product?: ProductConflictDto | undefined;
    requestorId?: string | undefined;
    requestor?: UserConflictDto | undefined;
    startDate?: Date;
    endDate?: Date;
    place?: string | undefined;
    estimatedCost?: number;

    constructor(data?: IRentRequestConflictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.requestDate = _data["requestDate"] ? new Date(_data["requestDate"].toString()) : <any>undefined;
            this.product = _data["product"] ? ProductConflictDto.fromJS(_data["product"]) : <any>undefined;
            this.requestorId = _data["requestorId"];
            this.requestor = _data["requestor"] ? UserConflictDto.fromJS(_data["requestor"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.place = _data["place"];
            this.estimatedCost = _data["estimatedCost"];
        }
    }

    static fromJS(data: any): RentRequestConflictDto {
        data = typeof data === 'object' ? data : {};
        let result = new RentRequestConflictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["requestorId"] = this.requestorId;
        data["requestor"] = this.requestor ? this.requestor.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["place"] = this.place;
        data["estimatedCost"] = this.estimatedCost;
        return data; 
    }
}

export interface IRentRequestConflictDto {
    id?: number;
    status?: RequestStatus;
    requestDate?: Date;
    product?: ProductConflictDto | undefined;
    requestorId?: string | undefined;
    requestor?: UserConflictDto | undefined;
    startDate?: Date;
    endDate?: Date;
    place?: string | undefined;
    estimatedCost?: number;
}

export enum RequestStatus {
    Pending = 0,
    Viewed = 1,
    Cancelled = 2,
    NotResolved = 3,
    Rejected = 4,
    Accepted = 5,
}

export class ProductConflictDto implements IProductConflictDto {
    id?: number;
    status?: ProductStatus;
    name?: string | undefined;
    description?: string | undefined;
    otherNames?: string | undefined;
    owner?: UserConflictDto | undefined;
    location?: UbicacionDto | undefined;
    costPerDay?: number;
    costPerWeek?: number | undefined;
    costPerMonth?: number | undefined;
    distanceInKm?: number | undefined;
    pictures?: ProductPictureDto[] | undefined;

    constructor(data?: IProductConflictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.otherNames = _data["otherNames"];
            this.owner = _data["owner"] ? UserConflictDto.fromJS(_data["owner"]) : <any>undefined;
            this.location = _data["location"] ? UbicacionDto.fromJS(_data["location"]) : <any>undefined;
            this.costPerDay = _data["costPerDay"];
            this.costPerWeek = _data["costPerWeek"];
            this.costPerMonth = _data["costPerMonth"];
            this.distanceInKm = _data["distanceInKm"];
            if (Array.isArray(_data["pictures"])) {
                this.pictures = [] as any;
                for (let item of _data["pictures"])
                    this.pictures!.push(ProductPictureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductConflictDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductConflictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        data["description"] = this.description;
        data["otherNames"] = this.otherNames;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["costPerDay"] = this.costPerDay;
        data["costPerWeek"] = this.costPerWeek;
        data["costPerMonth"] = this.costPerMonth;
        data["distanceInKm"] = this.distanceInKm;
        if (Array.isArray(this.pictures)) {
            data["pictures"] = [];
            for (let item of this.pictures)
                data["pictures"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductConflictDto {
    id?: number;
    status?: ProductStatus;
    name?: string | undefined;
    description?: string | undefined;
    otherNames?: string | undefined;
    owner?: UserConflictDto | undefined;
    location?: UbicacionDto | undefined;
    costPerDay?: number;
    costPerWeek?: number | undefined;
    costPerMonth?: number | undefined;
    distanceInKm?: number | undefined;
    pictures?: ProductPictureDto[] | undefined;
}

export enum ProductStatus {
    Incomplete = 0,
    Available = 1,
    NotAvailable = 2,
    Inactive = 3,
}

export class UserConflictDto implements IUserConflictDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;

    constructor(data?: IUserConflictDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UserConflictDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserConflictDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IUserConflictDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
}

export enum RentStatus {
    Pending = 0,
    ProductDelivered = 1,
    ProductReturned = 2,
    Cancelled = 3,
    ReturnDelayed = 4,
    NotCompleted = 5,
    Conflict = 6,
}

export class CreateConflictCommand implements ICreateConflictCommand {
    rentId?: number;
    description?: string | undefined;

    constructor(data?: ICreateConflictCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rentId = _data["rentId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateConflictCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateConflictCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rentId"] = this.rentId;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateConflictCommand {
    rentId?: number;
    description?: string | undefined;
}

export class CreateProductCategoryCommand implements ICreateProductCategoryCommand {
    productId?: number;
    categoryId?: number;

    constructor(data?: ICreateProductCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): CreateProductCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["categoryId"] = this.categoryId;
        return data; 
    }
}

export interface ICreateProductCategoryCommand {
    productId?: number;
    categoryId?: number;
}

export class PaginatedListResponseOfProductDto implements IPaginatedListResponseOfProductDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: ProductDto[] | undefined;

    constructor(data?: IPaginatedListResponseOfProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListResponseOfProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListResponseOfProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaginatedListResponseOfProductDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: ProductDto[] | undefined;
}

export class CategorySummaryDto implements ICategorySummaryDto {
    id?: number;
    name?: string | undefined;

    constructor(data?: ICategorySummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategorySummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICategorySummaryDto {
    id?: number;
    name?: string | undefined;
}

export class CreateProductCommand implements ICreateProductCommand {
    name?: string | undefined;
    description?: string | undefined;
    otherNames?: string | undefined;
    location?: Ubicacion | undefined;
    categories?: number[] | undefined;
    pictures?: number[] | undefined;
    costPerDay?: number;
    costPerWeek?: number | undefined;
    costPerMonth?: number | undefined;

    constructor(data?: ICreateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.otherNames = _data["otherNames"];
            this.location = _data["location"] ? Ubicacion.fromJS(_data["location"]) : <any>undefined;
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
            if (Array.isArray(_data["pictures"])) {
                this.pictures = [] as any;
                for (let item of _data["pictures"])
                    this.pictures!.push(item);
            }
            this.costPerDay = _data["costPerDay"];
            this.costPerWeek = _data["costPerWeek"];
            this.costPerMonth = _data["costPerMonth"];
        }
    }

    static fromJS(data: any): CreateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["otherNames"] = this.otherNames;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        if (Array.isArray(this.pictures)) {
            data["pictures"] = [];
            for (let item of this.pictures)
                data["pictures"].push(item);
        }
        data["costPerDay"] = this.costPerDay;
        data["costPerWeek"] = this.costPerWeek;
        data["costPerMonth"] = this.costPerMonth;
        return data; 
    }
}

export interface ICreateProductCommand {
    name?: string | undefined;
    description?: string | undefined;
    otherNames?: string | undefined;
    location?: Ubicacion | undefined;
    categories?: number[] | undefined;
    pictures?: number[] | undefined;
    costPerDay?: number;
    costPerWeek?: number | undefined;
    costPerMonth?: number | undefined;
}

export class Ubicacion implements IUbicacion {
    latitude?: number;
    longitude?: number;
    city?: string | undefined;
    state?: string | undefined;
    staticMap?: string | undefined;

    constructor(data?: IUbicacion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.staticMap = _data["staticMap"];
        }
    }

    static fromJS(data: any): Ubicacion {
        data = typeof data === 'object' ? data : {};
        let result = new Ubicacion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["city"] = this.city;
        data["state"] = this.state;
        data["staticMap"] = this.staticMap;
        return data; 
    }
}

export interface IUbicacion {
    latitude?: number;
    longitude?: number;
    city?: string | undefined;
    state?: string | undefined;
    staticMap?: string | undefined;
}

export class UpdateProductCommand implements IUpdateProductCommand {
    id?: number;
    status?: ProductStatus | undefined;
    name?: string | undefined;
    description?: string | undefined;
    otherNames?: string | undefined;
    costPerDay?: number | undefined;
    costPerWeek?: number | undefined;
    costPerMonth?: number | undefined;
    location?: Ubicacion | undefined;
    categoriesToRemove?: number[] | undefined;
    newCategories?: number[] | undefined;
    picturesToRemove?: number[] | undefined;
    newPictures?: number[] | undefined;

    constructor(data?: IUpdateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.otherNames = _data["otherNames"];
            this.costPerDay = _data["costPerDay"];
            this.costPerWeek = _data["costPerWeek"];
            this.costPerMonth = _data["costPerMonth"];
            this.location = _data["location"] ? Ubicacion.fromJS(_data["location"]) : <any>undefined;
            if (Array.isArray(_data["categoriesToRemove"])) {
                this.categoriesToRemove = [] as any;
                for (let item of _data["categoriesToRemove"])
                    this.categoriesToRemove!.push(item);
            }
            if (Array.isArray(_data["newCategories"])) {
                this.newCategories = [] as any;
                for (let item of _data["newCategories"])
                    this.newCategories!.push(item);
            }
            if (Array.isArray(_data["picturesToRemove"])) {
                this.picturesToRemove = [] as any;
                for (let item of _data["picturesToRemove"])
                    this.picturesToRemove!.push(item);
            }
            if (Array.isArray(_data["newPictures"])) {
                this.newPictures = [] as any;
                for (let item of _data["newPictures"])
                    this.newPictures!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        data["description"] = this.description;
        data["otherNames"] = this.otherNames;
        data["costPerDay"] = this.costPerDay;
        data["costPerWeek"] = this.costPerWeek;
        data["costPerMonth"] = this.costPerMonth;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        if (Array.isArray(this.categoriesToRemove)) {
            data["categoriesToRemove"] = [];
            for (let item of this.categoriesToRemove)
                data["categoriesToRemove"].push(item);
        }
        if (Array.isArray(this.newCategories)) {
            data["newCategories"] = [];
            for (let item of this.newCategories)
                data["newCategories"].push(item);
        }
        if (Array.isArray(this.picturesToRemove)) {
            data["picturesToRemove"] = [];
            for (let item of this.picturesToRemove)
                data["picturesToRemove"].push(item);
        }
        if (Array.isArray(this.newPictures)) {
            data["newPictures"] = [];
            for (let item of this.newPictures)
                data["newPictures"].push(item);
        }
        return data; 
    }
}

export interface IUpdateProductCommand {
    id?: number;
    status?: ProductStatus | undefined;
    name?: string | undefined;
    description?: string | undefined;
    otherNames?: string | undefined;
    costPerDay?: number | undefined;
    costPerWeek?: number | undefined;
    costPerMonth?: number | undefined;
    location?: Ubicacion | undefined;
    categoriesToRemove?: number[] | undefined;
    newCategories?: number[] | undefined;
    picturesToRemove?: number[] | undefined;
    newPictures?: number[] | undefined;
}

export class RatingToProductDto implements IRatingToProductDto {
    id?: number;
    status?: RatingStatus;
    fromUserId?: string | undefined;
    fromUser?: UserRatingDto | undefined;
    productId?: number;
    product?: ProductRatingDto | undefined;
    productRatingValue?: number | undefined;
    ownerRatingValue?: number | undefined;
    comment?: string | undefined;
    ratingDate?: Date | undefined;

    constructor(data?: IRatingToProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.fromUserId = _data["fromUserId"];
            this.fromUser = _data["fromUser"] ? UserRatingDto.fromJS(_data["fromUser"]) : <any>undefined;
            this.productId = _data["productId"];
            this.product = _data["product"] ? ProductRatingDto.fromJS(_data["product"]) : <any>undefined;
            this.productRatingValue = _data["productRatingValue"];
            this.ownerRatingValue = _data["ownerRatingValue"];
            this.comment = _data["comment"];
            this.ratingDate = _data["ratingDate"] ? new Date(_data["ratingDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RatingToProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new RatingToProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["fromUserId"] = this.fromUserId;
        data["fromUser"] = this.fromUser ? this.fromUser.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["productRatingValue"] = this.productRatingValue;
        data["ownerRatingValue"] = this.ownerRatingValue;
        data["comment"] = this.comment;
        data["ratingDate"] = this.ratingDate ? this.ratingDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRatingToProductDto {
    id?: number;
    status?: RatingStatus;
    fromUserId?: string | undefined;
    fromUser?: UserRatingDto | undefined;
    productId?: number;
    product?: ProductRatingDto | undefined;
    productRatingValue?: number | undefined;
    ownerRatingValue?: number | undefined;
    comment?: string | undefined;
    ratingDate?: Date | undefined;
}

export enum RatingStatus {
    Pending = 0,
    Ignored = 1,
    Rated = 2,
}

export class UserRatingDto implements IUserRatingDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    profilePicture?: Picture | undefined;
    reputation?: number | undefined;

    constructor(data?: IUserRatingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.profilePicture = _data["profilePicture"] ? Picture.fromJS(_data["profilePicture"]) : <any>undefined;
            this.reputation = _data["reputation"];
        }
    }

    static fromJS(data: any): UserRatingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRatingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["profilePicture"] = this.profilePicture ? this.profilePicture.toJSON() : <any>undefined;
        data["reputation"] = this.reputation;
        return data; 
    }
}

export interface IUserRatingDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    profilePicture?: Picture | undefined;
    reputation?: number | undefined;
}

export class Picture implements IPicture {
    id?: number;
    storageType?: PictureStorageType;
    pictureContent?: string | undefined;

    constructor(data?: IPicture) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storageType = _data["storageType"];
            this.pictureContent = _data["pictureContent"];
        }
    }

    static fromJS(data: any): Picture {
        data = typeof data === 'object' ? data : {};
        let result = new Picture();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storageType"] = this.storageType;
        data["pictureContent"] = this.pictureContent;
        return data; 
    }
}

export interface IPicture {
    id?: number;
    storageType?: PictureStorageType;
    pictureContent?: string | undefined;
}

export enum PictureStorageType {
    Url = 0,
    Base64 = 1,
}

export class ProductRatingDto implements IProductRatingDto {
    id?: number;
    name?: string | undefined;
    owner?: UserRatingDto | undefined;
    picture?: Picture | undefined;

    constructor(data?: IProductRatingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.owner = _data["owner"] ? UserRatingDto.fromJS(_data["owner"]) : <any>undefined;
            this.picture = _data["picture"] ? Picture.fromJS(_data["picture"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductRatingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductRatingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["picture"] = this.picture ? this.picture.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductRatingDto {
    id?: number;
    name?: string | undefined;
    owner?: UserRatingDto | undefined;
    picture?: Picture | undefined;
}

export class PaginatedListResponseOfRatingToProductDto implements IPaginatedListResponseOfRatingToProductDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: RatingToProductDto[] | undefined;

    constructor(data?: IPaginatedListResponseOfRatingToProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RatingToProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListResponseOfRatingToProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListResponseOfRatingToProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaginatedListResponseOfRatingToProductDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: RatingToProductDto[] | undefined;
}

export class RateProductCommand implements IRateProductCommand {
    ratingId?: number;
    productRatingValue?: number;
    ownerRatingValue?: number;
    comment?: string | undefined;

    constructor(data?: IRateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ratingId = _data["ratingId"];
            this.productRatingValue = _data["productRatingValue"];
            this.ownerRatingValue = _data["ownerRatingValue"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): RateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ratingId"] = this.ratingId;
        data["productRatingValue"] = this.productRatingValue;
        data["ownerRatingValue"] = this.ownerRatingValue;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IRateProductCommand {
    ratingId?: number;
    productRatingValue?: number;
    ownerRatingValue?: number;
    comment?: string | undefined;
}

export class RatingToUserDto implements IRatingToUserDto {
    id?: number;
    status?: RatingStatus;
    toUser?: UserRatingDto | undefined;

    constructor(data?: IRatingToUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.toUser = _data["toUser"] ? UserRatingDto.fromJS(_data["toUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RatingToUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RatingToUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["toUser"] = this.toUser ? this.toUser.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRatingToUserDto {
    id?: number;
    status?: RatingStatus;
    toUser?: UserRatingDto | undefined;
}

export class RateUserCommand implements IRateUserCommand {
    ratingId?: number;
    ratingValue?: number;

    constructor(data?: IRateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ratingId = _data["ratingId"];
            this.ratingValue = _data["ratingValue"];
        }
    }

    static fromJS(data: any): RateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ratingId"] = this.ratingId;
        data["ratingValue"] = this.ratingValue;
        return data; 
    }
}

export interface IRateUserCommand {
    ratingId?: number;
    ratingValue?: number;
}

export class RejectRentRequestCommand implements IRejectRentRequestCommand {
    rentRequestId?: number;
    message?: string | undefined;

    constructor(data?: IRejectRentRequestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rentRequestId = _data["rentRequestId"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): RejectRentRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RejectRentRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rentRequestId"] = this.rentRequestId;
        data["message"] = this.message;
        return data; 
    }
}

export interface IRejectRentRequestCommand {
    rentRequestId?: number;
    message?: string | undefined;
}

export class RentRequestDto implements IRentRequestDto {
    id?: number;
    status?: RequestStatus;
    requestDate?: Date;
    startDate?: Date;
    endDate?: Date;
    place?: string | undefined;
    estimatedCost?: number;
    requestor?: RentRequestProductOwnerDto | undefined;
    product?: RentRequestProductDto | undefined;
    events?: RequestEventDto[] | undefined;

    constructor(data?: IRentRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.requestDate = _data["requestDate"] ? new Date(_data["requestDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.place = _data["place"];
            this.estimatedCost = _data["estimatedCost"];
            this.requestor = _data["requestor"] ? RentRequestProductOwnerDto.fromJS(_data["requestor"]) : <any>undefined;
            this.product = _data["product"] ? RentRequestProductDto.fromJS(_data["product"]) : <any>undefined;
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(RequestEventDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RentRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new RentRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["place"] = this.place;
        data["estimatedCost"] = this.estimatedCost;
        data["requestor"] = this.requestor ? this.requestor.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRentRequestDto {
    id?: number;
    status?: RequestStatus;
    requestDate?: Date;
    startDate?: Date;
    endDate?: Date;
    place?: string | undefined;
    estimatedCost?: number;
    requestor?: RentRequestProductOwnerDto | undefined;
    product?: RentRequestProductDto | undefined;
    events?: RequestEventDto[] | undefined;
}

export class RentRequestProductOwnerDto implements IRentRequestProductOwnerDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    profilePicture?: Picture | undefined;
    reputation?: number | undefined;

    constructor(data?: IRentRequestProductOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.profilePicture = _data["profilePicture"] ? Picture.fromJS(_data["profilePicture"]) : <any>undefined;
            this.reputation = _data["reputation"];
        }
    }

    static fromJS(data: any): RentRequestProductOwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new RentRequestProductOwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["profilePicture"] = this.profilePicture ? this.profilePicture.toJSON() : <any>undefined;
        data["reputation"] = this.reputation;
        return data; 
    }
}

export interface IRentRequestProductOwnerDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    profilePicture?: Picture | undefined;
    reputation?: number | undefined;
}

export class RentRequestProductDto implements IRentRequestProductDto {
    id?: number;
    name?: string | undefined;
    rating?: number | undefined;
    owner?: RentRequestProductOwnerDto | undefined;
    picture?: ProductPictureDto | undefined;

    constructor(data?: IRentRequestProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rating = _data["rating"];
            this.owner = _data["owner"] ? RentRequestProductOwnerDto.fromJS(_data["owner"]) : <any>undefined;
            this.picture = _data["picture"] ? ProductPictureDto.fromJS(_data["picture"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RentRequestProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new RentRequestProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rating"] = this.rating;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["picture"] = this.picture ? this.picture.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRentRequestProductDto {
    id?: number;
    name?: string | undefined;
    rating?: number | undefined;
    owner?: RentRequestProductOwnerDto | undefined;
    picture?: ProductPictureDto | undefined;
}

export class RequestEventDto implements IRequestEventDto {
    id?: number;
    rentRequestId?: number;
    eventType?: RequestEventType;
    eventDate?: Date;
    message?: string | undefined;

    constructor(data?: IRequestEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rentRequestId = _data["rentRequestId"];
            this.eventType = _data["eventType"];
            this.eventDate = _data["eventDate"] ? new Date(_data["eventDate"].toString()) : <any>undefined;
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): RequestEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rentRequestId"] = this.rentRequestId;
        data["eventType"] = this.eventType;
        data["eventDate"] = this.eventDate ? this.eventDate.toISOString() : <any>undefined;
        data["message"] = this.message;
        return data; 
    }
}

export interface IRequestEventDto {
    id?: number;
    rentRequestId?: number;
    eventType?: RequestEventType;
    eventDate?: Date;
    message?: string | undefined;
}

export enum RequestEventType {
    RequestViewed = 0,
    RequestCancelled = 1,
    RequestAccepted = 2,
    RequestRejected = 3,
}

export class PaginatedListResponseOfRentRequestDto implements IPaginatedListResponseOfRentRequestDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: RentRequestDto[] | undefined;

    constructor(data?: IPaginatedListResponseOfRentRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RentRequestDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListResponseOfRentRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListResponseOfRentRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaginatedListResponseOfRentRequestDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: RentRequestDto[] | undefined;
}

export class CreateRentRequestCommand implements ICreateRentRequestCommand {
    productId?: number;
    startDate?: Date;
    endDate?: Date;
    place?: string | undefined;

    constructor(data?: ICreateRentRequestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.place = _data["place"];
        }
    }

    static fromJS(data: any): CreateRentRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRentRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["place"] = this.place;
        return data; 
    }
}

export interface ICreateRentRequestCommand {
    productId?: number;
    startDate?: Date;
    endDate?: Date;
    place?: string | undefined;
}

export class RentDto implements IRentDto {
    requestId?: number;
    status?: RentStatus;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    totalCost?: number | undefined;

    constructor(data?: IRentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.status = _data["status"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.totalCost = _data["totalCost"];
        }
    }

    static fromJS(data: any): RentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["status"] = this.status;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["totalCost"] = this.totalCost;
        return data; 
    }
}

export interface IRentDto {
    requestId?: number;
    status?: RentStatus;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    totalCost?: number | undefined;
}

export class PaginatedListResponseOfRentRequestRentDto implements IPaginatedListResponseOfRentRequestRentDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: RentRequestRentDto[] | undefined;

    constructor(data?: IPaginatedListResponseOfRentRequestRentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RentRequestRentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListResponseOfRentRequestRentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListResponseOfRentRequestRentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaginatedListResponseOfRentRequestRentDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: RentRequestRentDto[] | undefined;
}

export class RentRequestRentDto implements IRentRequestRentDto {
    id?: number;
    status?: RequestStatus;
    requestDate?: Date;
    startDate?: Date;
    endDate?: Date;
    place?: string | undefined;
    estimatedCost?: number;
    rent?: RentDto | undefined;
    requestor?: RentRequestProductOwnerDto | undefined;
    product?: RentRequestProductDto | undefined;
    events?: RequestEventDto[] | undefined;

    constructor(data?: IRentRequestRentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.requestDate = _data["requestDate"] ? new Date(_data["requestDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.place = _data["place"];
            this.estimatedCost = _data["estimatedCost"];
            this.rent = _data["rent"] ? RentDto.fromJS(_data["rent"]) : <any>undefined;
            this.requestor = _data["requestor"] ? RentRequestProductOwnerDto.fromJS(_data["requestor"]) : <any>undefined;
            this.product = _data["product"] ? RentRequestProductDto.fromJS(_data["product"]) : <any>undefined;
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(RequestEventDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RentRequestRentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RentRequestRentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["place"] = this.place;
        data["estimatedCost"] = this.estimatedCost;
        data["rent"] = this.rent ? this.rent.toJSON() : <any>undefined;
        data["requestor"] = this.requestor ? this.requestor.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRentRequestRentDto {
    id?: number;
    status?: RequestStatus;
    requestDate?: Date;
    startDate?: Date;
    endDate?: Date;
    place?: string | undefined;
    estimatedCost?: number;
    rent?: RentDto | undefined;
    requestor?: RentRequestProductOwnerDto | undefined;
    product?: RentRequestProductDto | undefined;
    events?: RequestEventDto[] | undefined;
}

export class EndRentCommand implements IEndRentCommand {
    rentId?: number;
    ratingValue?: number;

    constructor(data?: IEndRentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rentId = _data["rentId"];
            this.ratingValue = _data["ratingValue"];
        }
    }

    static fromJS(data: any): EndRentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EndRentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rentId"] = this.rentId;
        data["ratingValue"] = this.ratingValue;
        return data; 
    }
}

export interface IEndRentCommand {
    rentId?: number;
    ratingValue?: number;
}

export class RentsByDayReport implements IRentsByDayReport {
    year?: number;
    month?: number;
    results?: DayResult[] | undefined;

    constructor(data?: IRentsByDayReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.month = _data["month"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DayResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RentsByDayReport {
        data = typeof data === 'object' ? data : {};
        let result = new RentsByDayReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRentsByDayReport {
    year?: number;
    month?: number;
    results?: DayResult[] | undefined;
}

export class DayResult implements IDayResult {
    day?: number;
    total?: number;

    constructor(data?: IDayResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day = _data["day"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): DayResult {
        data = typeof data === 'object' ? data : {};
        let result = new DayResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["day"] = this.day;
        data["total"] = this.total;
        return data; 
    }
}

export interface IDayResult {
    day?: number;
    total?: number;
}

export class RentsByMonthReport implements IRentsByMonthReport {
    year?: number;
    results?: MonthResult[] | undefined;

    constructor(data?: IRentsByMonthReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(MonthResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RentsByMonthReport {
        data = typeof data === 'object' ? data : {};
        let result = new RentsByMonthReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRentsByMonthReport {
    year?: number;
    results?: MonthResult[] | undefined;
}

export class MonthResult implements IMonthResult {
    month?: number;
    total?: number;

    constructor(data?: IMonthResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): MonthResult {
        data = typeof data === 'object' ? data : {};
        let result = new MonthResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["total"] = this.total;
        return data; 
    }
}

export interface IMonthResult {
    month?: number;
    total?: number;
}

export class RentsByYearReport implements IRentsByYearReport {
    results?: YearResult[] | undefined;

    constructor(data?: IRentsByYearReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(YearResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RentsByYearReport {
        data = typeof data === 'object' ? data : {};
        let result = new RentsByYearReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRentsByYearReport {
    results?: YearResult[] | undefined;
}

export class YearResult implements IYearResult {
    year?: number;
    total?: number;

    constructor(data?: IYearResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): YearResult {
        data = typeof data === 'object' ? data : {};
        let result = new YearResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["total"] = this.total;
        return data; 
    }
}

export interface IYearResult {
    year?: number;
    total?: number;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;

    constructor(data?: ICreateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listId = _data["listId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["title"] = this.title;
        return data; 
    }
}

export interface ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: IUpdateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): UpdateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["done"] = this.done;
        return data; 
    }
}

export interface IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;
}

export class UpdateTodoItemDetailCommand implements IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;

    constructor(data?: IUpdateTodoItemDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateTodoItemDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data; 
    }
}

export interface IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TodosVm implements ITodosVm {
    priorityLevels?: PriorityLevelDto[] | undefined;
    lists?: TodoListDto[] | undefined;

    constructor(data?: ITodosVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priorityLevels"])) {
                this.priorityLevels = [] as any;
                for (let item of _data["priorityLevels"])
                    this.priorityLevels!.push(PriorityLevelDto.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(TodoListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodosVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodosVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priorityLevels)) {
            data["priorityLevels"] = [];
            for (let item of this.priorityLevels)
                data["priorityLevels"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITodosVm {
    priorityLevels?: PriorityLevelDto[] | undefined;
    lists?: TodoListDto[] | undefined;
}

export class PriorityLevelDto implements IPriorityLevelDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IPriorityLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PriorityLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPriorityLevelDto {
    value?: number;
    name?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
    id?: number;
    title?: string | undefined;
    items?: TodoItemDto[] | undefined;

    constructor(data?: ITodoListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITodoListDto {
    id?: number;
    title?: string | undefined;
    items?: TodoItemDto[] | undefined;
}

export class TodoItemDto implements ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;

    constructor(data?: ITodoItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TodoItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data; 
    }
}

export interface ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
    title?: string | undefined;

    constructor(data?: ICreateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data; 
    }
}

export interface ICreateTodoListCommand {
    title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;

    constructor(data?: IUpdateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }
}

export interface IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;
}

export class PaginatedListResponseOfUserProfileDto implements IPaginatedListResponseOfUserProfileDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: UserProfileDto[] | undefined;

    constructor(data?: IPaginatedListResponseOfUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.hasPrevious = _data["hasPrevious"];
            this.hasNext = _data["hasNext"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserProfileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListResponseOfUserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListResponseOfUserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["hasPrevious"] = this.hasPrevious;
        data["hasNext"] = this.hasNext;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaginatedListResponseOfUserProfileDto {
    currentPage?: number;
    totalPages?: number;
    pageSize?: number;
    totalCount?: number;
    hasPrevious?: boolean;
    hasNext?: boolean;
    items?: UserProfileDto[] | undefined;
}

export class UserProfileDto implements IUserProfileDto {
    id?: string | undefined;
    profileStatus?: UserProfileStatus;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    reputation?: number | undefined;
    cui?: string | undefined;
    validatedDpi?: boolean;
    address?: string | undefined;
    validatedAddress?: boolean;
    profilePicture?: Picture | undefined;
    userPicture?: Picture | undefined;
    dpiPicture?: Picture | undefined;
    addressPicture?: Picture | undefined;

    constructor(data?: IUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.profileStatus = _data["profileStatus"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.reputation = _data["reputation"];
            this.cui = _data["cui"];
            this.validatedDpi = _data["validatedDpi"];
            this.address = _data["address"];
            this.validatedAddress = _data["validatedAddress"];
            this.profilePicture = _data["profilePicture"] ? Picture.fromJS(_data["profilePicture"]) : <any>undefined;
            this.userPicture = _data["userPicture"] ? Picture.fromJS(_data["userPicture"]) : <any>undefined;
            this.dpiPicture = _data["dpiPicture"] ? Picture.fromJS(_data["dpiPicture"]) : <any>undefined;
            this.addressPicture = _data["addressPicture"] ? Picture.fromJS(_data["addressPicture"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["profileStatus"] = this.profileStatus;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["reputation"] = this.reputation;
        data["cui"] = this.cui;
        data["validatedDpi"] = this.validatedDpi;
        data["address"] = this.address;
        data["validatedAddress"] = this.validatedAddress;
        data["profilePicture"] = this.profilePicture ? this.profilePicture.toJSON() : <any>undefined;
        data["userPicture"] = this.userPicture ? this.userPicture.toJSON() : <any>undefined;
        data["dpiPicture"] = this.dpiPicture ? this.dpiPicture.toJSON() : <any>undefined;
        data["addressPicture"] = this.addressPicture ? this.addressPicture.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserProfileDto {
    id?: string | undefined;
    profileStatus?: UserProfileStatus;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    reputation?: number | undefined;
    cui?: string | undefined;
    validatedDpi?: boolean;
    address?: string | undefined;
    validatedAddress?: boolean;
    profilePicture?: Picture | undefined;
    userPicture?: Picture | undefined;
    dpiPicture?: Picture | undefined;
    addressPicture?: Picture | undefined;
}

export enum UserProfileStatus {
    Incomplete = 0,
    WaitingForApproval = 1,
    Rejected = 2,
    Active = 3,
    Inactive = 4,
}

export class SendPhoneNumberVerificationCode implements ISendPhoneNumberVerificationCode {
    phoneNumber?: string | undefined;

    constructor(data?: ISendPhoneNumberVerificationCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendPhoneNumberVerificationCode {
        data = typeof data === 'object' ? data : {};
        let result = new SendPhoneNumberVerificationCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ISendPhoneNumberVerificationCode {
    phoneNumber?: string | undefined;
}

export class ValidateUserPhoneNumberCommand implements IValidateUserPhoneNumberCommand {
    phoneNumber?: string | undefined;
    verificationCode?: string | undefined;

    constructor(data?: IValidateUserPhoneNumberCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
            this.verificationCode = _data["verificationCode"];
        }
    }

    static fromJS(data: any): ValidateUserPhoneNumberCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateUserPhoneNumberCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        data["verificationCode"] = this.verificationCode;
        return data; 
    }
}

export interface IValidateUserPhoneNumberCommand {
    phoneNumber?: string | undefined;
    verificationCode?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data; 
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}